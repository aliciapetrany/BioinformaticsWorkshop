---
title: "Bioinformatics Club R/ggplot Workshop"
output: 
    rmarkdown::html_document:
        number_sections: true
        toc: true
        toc_depth: 2
        theme: cerulean
       
        
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>"
)
```
# Scenario

We have 20 different mice. Some of them have a genetic mutation that causes a rare disease called wobbly whisker syndrome (wws)! It's our job to figure out which mutation is the culprit. We've been given some genotype and RNA-seq data for all of the mice. Lets dig into it to see if we can figure out where the mutation is, and how it affects the their transcriptional profiles.

# R Basics
Before we can get started with the analysis, we have to go over some basic R commands.
We are going to be using two different data structures in this tutorial. The first is a vector:
```{r eval=T}
#make the vectors
x <- c(1, 2, 3) 
y <- c(4, 5, 6)

print(x)
print(y)
```
Vectors are indexed with square brackets []. Unlike most other languages, indexing starts at 1, not 0. 
```{r eval=T}
print(x[1])
```

We will also use dataframes. Think of dataframes as a 2-dimensional table, similar to an excel spreadsheet. Here is how you define one: 
```{r eval=T}
df = data.frame(
  column1 = c(1, 2, 3),
  column2 = c(4, 5, 6), 
  column3 = c("x", "y", "z")
)
print(df)
```
All rows and columns of a dataframe can be numerically indexed similarly to vectors with the format df[rows, columns]. Specific columns can also be accessed with the $ operator. 
```{r eval=T}
df[1,] #get the first row
df[,2:3] #get second and third column
df$column1 #return values in first column as a vector
```
Finally, we're quickly going to go over control structures and loops. Sometimes, we'll only want a code block to execute if another condition is true. To do this, we'll use an if statement:
```{r eval=T}
x = 3

if(x == 3){
  print("x is 3")
}else{
  print("x is not 3")
}
```
Sometimes, we'll want to repeat the same task a set number of times. A common example of this is running the same operation on every row of a data frame. To do this, we will use a "for" loop: 
```{r eval=T}
#let's add one to every value in x
x = c(1, 2, 3)

for(i in 1:length(x)){
  x[i] <- x[i] + 1
}
print(x)
```
That's it for the basics! We'll go more in depth about them as we get further into this tutorial. 

# Analysis
## Loading in our data
Typically, at the start of every R script, we load in any libraries we will need for the analysis. Libraries are chunks of code that other people have already written for us, so we can save time! We will be using two in this tutorial: 
```{r eval=T}
library(ggplot2)
library(ggpubr)

```
The wet lab researchers for this project have sent us two csv files. One for the genotype data, and one for the RNA-seq data. Lets load them in and take a look at them!
```{r eval=T}
gdf <- read.csv("genotype_data.csv")
rna.counts <- read.csv("rnaseq_counts.csv")
rownames(rna.counts) <- rna.counts$X #set the rownames to the first column! read.csv won't do it for you
rna.counts <- rna.counts[,-1] #get rid of the extra gene name column once row names are set
de.analysis <- read.csv("rnaseq_DE_results.csv")
```
First, lets check out the genotype data. Each row represents a site where mice commonly have mutations. The first two columns are the chromosome and coordinate of each site. The third column is the name of the gene that the mutation affects, and the fourth column is a fishers exact pvalue representing the probability that the mutation is associated with the wws mice. The remaining columns are the nucleotides that each mouse has at each site. 
```{r eval=T}
head(gdf, 2)

```
The RNA-sequencing data shows the number of transcripts sequenced for each gene within each mouse sample: 
```{r eval=T}
head(rna.counts, 2)

```
We also have some differential expression analysis results for the RNA-seq data. This dataframe has the log2 fold change for each gene, as well as a p-value generated by DESeq2. We can use this to find genes that are significantly up or down regulated between the wws and the wt mice. 
```{r eval=T}
head(de.analysis, 2)

```

## Basic Genotyping QC
Usually, bioinformaticians will check the frequencies of each nucelotide for QC purposes. We can do this with a simple bar graph. First, copy and paste this block of code into your R session to get a dataframe that has the frequecy of each nucelotide. If you want to see how each line works, you can highlight certain parts of each command and press ctrl+enter to see their output. 
```{r eval=T}
nuc.freqs <- table(unlist(gdf[5:ncol(gdf)])) 
nuc.freqs <- as.data.frame(nuc.freqs)
nuc.freqs$Freq <- nuc.freqs$Freq/sum(nuc.freqs$Freq)
nuc.freqs$Var1 <- factor(nuc.freqs$Var1,
                         levels = c("A", "T", "C", "G", "H", "N"))
print(nuc.freqs)
```
Now, let's make a bar graph that shows us the relative proportions of each nucleotide. You should notice that the A/T and G/C have similar frequencies, and Heterozygous/Deletion calls are much less frequent. 
```{r eval=T}
ggplot(nuc.freqs, aes(x = Var1, y = Freq))+
  geom_bar(stat = "identity", fill = "grey20") +
  theme_classic() +
  scale_y_continuous(expand = c(0,0)) +
  xlab("Nucleotide")  +
  ylab("Proportion")

```
## Looking at significant genotype hits
Lets filter our genotype sites for hits that could be associated with wws. 
```{r eval=T}
targets <- gdf[gdf$p.val == min(gdf$p.val),]
print(targets)
```
We have some interesting hits! Lets look at the histograms for their corresponding RNA-seq data. First, we have to retrieve the counts for these genes:
```{r eval=T}
target.counts <- rna.counts[rownames(rna.counts) %in% targets$gene, ]
```
Now, we have to "melt" the counts down so that they're compatible with ggplot2:
```{r eval=T}
histdf <- data.frame()
for(i in 1:nrow(target.counts)){
  counts <- as.numeric(target.counts[i,])
  gname <- rownames(target.counts)[i]
  conds <- c(rep("wws", 30), rep("wt", 30))  #30 because there are 3 samples for each mouse
  temp <- data.frame(
    gene = gname,
    condition = conds,
    counts = counts
  )
  histdf <- rbind(histdf, temp)
}
head(histdf)
```
Let's make a histogram for the first gene in the list, vhf0y3. Following our last example, this is is how we would make the histogram:
```{r eval=T, fig.align = "center"}
ggplot(histdf[histdf$gene == "vhf0y3",],
       aes(x = counts, fill = condition)) +
  geom_histogram(alpha = 0.5)
```
However, this doesn't do what we want! This stacks the histogram bars on top of eachother. We want them to be overlapping, not stacked, so we have to separate them out into two separate layers. 
```{r eval=T}
subhistdf <- histdf[histdf$gene == "vhf0y3",]

ggplot() +
  geom_histogram(data = subhistdf[subhistdf$condition == "wws",],
                 aes(x = counts),
                 alpha = 0.5,
                 fill = "darkblue",
                 inherit.aes = F) +
  geom_histogram(data = subhistdf[subhistdf$condition == "wt",],
                 aes(x = counts),
                 alpha = 0.5,
                 fill = "darkred",
                 inherit.aes = F) +
  theme_classic() +
  scale_y_continuous(expand = c(0,0))  +
  xlab("Expression Level") +
  ggtitle("Wbbl1") +
  theme(plot.title = element_text(hjust = 0.5))
```
<p></p>This makes the plot we are looking for, but only for a single gene! We want to look at all six candidates, so we are going to write a function that will replicate this plot for any gene we want to look at. The name of this function will be "plot_expression_hist". We are going to give it our data and the gene we want to look at, and it will return the plot. 
```{r eval=T, fig.align = "center"}
plot_expression_hist <- function(histdf, gene){
  subhistdf <- histdf[histdf$gene == gene,] #get the gene we want
  p <- ggplot() +
    geom_histogram(data = subhistdf[subhistdf$condition == "wws",],
                   aes(x = counts),
                   alpha = 0.5,
                   fill = "darkblue") +
    geom_histogram(data = subhistdf[subhistdf$condition == "wt",],
                   aes(x = counts),
                   alpha = 0.5,
                   fill = "darkred") +
    theme_classic() +
    scale_y_continuous(expand = c(0,0))  +
    xlab("Expression Level") +
    ggtitle(gene) +
    theme(plot.title = element_text(hjust = 0.5))
  return(p) #return the plot
}
```
Now that our function is written, we can make a plot for each of our six genes: 
```{r eval=T}
hist1 <- plot_expression_hist(histdf, "vhf0y3")
hist2 <- plot_expression_hist(histdf, "79vqc")
hist3 <- plot_expression_hist(histdf, "ndagq")
hist4 <- plot_expression_hist(histdf, "e7x")
hist5 <- plot_expression_hist(histdf, "w6dfxj")
hist6 <- plot_expression_hist(histdf, "Wbbl1")
```
Finally, we can use ggarrange from the ggpubr package to merge all of these plots together:
```{r eval=T, fig.align = "center"}
expression_hists <- ggarrange(hist1, hist2, hist3, hist4, hist5, hist6, nrow = 2, ncol = 3)
expression_hists
```
By looking at the histograms, we can see that Wbbl1 has a huge expression level difference between the wws and the wt mice. The single blue bar indicates that wws mice have little to no expression of Wbbl1. Because we are good biologists, we know that Wbbl1 is short for whisker balance breakdown locus 1, and that this gene plays a major role in whisker stabilization!

## Confirming Up And Downregulated Genes
Now that we know that Wbbl1 might be our culprit for wws in these mice, lets look into the formal differential expression analysis data. We are going to make a volcano plot, which is what bioinformatians use to compare the magnitude of a genes up/down regulation (log2 foldchange, or lfc for short) against the probability that any up/down regulation is statistically significant. 
```{r eval=T, fig.align = "center"}
de.analysis$color <- "up"
de.analysis$color[de.analysis$log2FoldChange < 0] <- "down"
de.analysis$padj[de.analysis$padj == 0] <- 10^-300

volcano <- ggplot(de.analysis, aes(x = log2FoldChange, y = -log10(padj), color = color)) +
  geom_point() +
  scale_color_manual(values = c("darkblue", "darkred")) +
  xlim(-10, 10) +
  ylim(0, 325)+
  geom_hline(yintercept = -log(0.05), linetype = "dashed") +
  geom_text(data = de.analysis[de.analysis$log2FoldChange < -5, ],
            aes(label = X ),
            color = "black",
            check_overlap = T,
            nudge_y = 10) +
  theme_classic() +
  theme(legend.position = "none")
volcano
```

## Tackling the dreaded heatmap
Bioinforamticians love to use heatmaps as an effective visualization, but making them isn't always the most straightforward. To demonstrate how to make a heatmap, we will make an expression heatmap from the RNA-seq data. First, we have to melt our data again. The code to do this is shown below, but don't run it! It will take a few minutes, so load in the pre-made csv file containing the output instead. 
```{r eval=F}
heatmapdf <- data.frame()
for(i in 1:nrow(rna.counts)){
  counts <- as.numeric(rna.counts[i,])
  gname <- rownames(rna.counts)[i]
  conds <- c(rep("wws", 30), rep("wt", 30))

  if(de.analysis$log2FoldChange[i] < -5){
    cluster <- "Downregulated"
  }else{
    cluster <- "Other"
  }
  temp <- data.frame(
    gene = gname,
    condition = conds,
    counts = counts,
    mouse = colnames(rna.counts),
    cluster = cluster
  )
  heatmapdf <- rbind(heatmapdf, temp)
}
heatmapdf$counts <- log(heatmapdf$counts +1)
```
Here is the code to make the heatmap:
```{r eval=T, fig.align = "center"}
heatmapdf <- read.csv("heatmapdf.csv")
geneorder <- de.analysis$X[order(de.analysis$log2FoldChange)]


heatmapdf$gene <- factor(heatmapdf$gene, levels = geneorder)

ggplot(heatmapdf, aes(x = mouse, y = gene, fill = counts)) +
  geom_tile()+
  scale_fill_viridis_b(option = "A") +
  facet_grid(cluster~condition, scales = "free")+
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())
```
